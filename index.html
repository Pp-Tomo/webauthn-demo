<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta
            http-equiv="Permissions-Policy"
            content="publickey-credentials-get=*; publickey-credentials-create=*"
        />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebAuthn Passkey Demo</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #555;
        }
        
        input[type="email"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            box-sizing: border-box;
        }
        
        input[type="email"]:focus {
            outline: none;
            border-color: #007AFF;
        }
        
        .button-group {
            display: flex;
            gap: 15px;
            margin-top: 30px;
        }
        
        button {
            flex: 1;
            padding: 15px 25px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        #register {
            background: #007AFF;
            color: white;
        }
        
        #register:hover:not(:disabled) {
            background: #0056CC;
        }
        
        #login {
            background: #34C759;
            color: white;
        }
        
        #login:hover:not(:disabled) {
            background: #28A745;
        }
        
        .status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            display: none;
        }
        
        .status.success {
            background: #D4F6DC;
            color: #0F5132;
            border: 1px solid #34C759;
        }
        
        .status.error {
            background: #F8D7DA;
            color: #721C24;
            border: 1px solid #DC3545;
        }
        
        .status.info {
            background: #CCE5FF;
            color: #004085;
            border: 1px solid #007AFF;
        }
        
        .fingerprint-icon {
            text-align: center;
            font-size: 48px;
            margin: 20px 0;
        }
        
        .support-info {
            margin-top: 20px;
            padding: 15px;
            background: #FFF3CD;
            border: 1px solid #FFECB5;
            border-radius: 8px;
            font-size: 14px;
            color: #664D03;
        }
        
        .auth-type-selector {
            margin: 20px 0;
            padding: 15px;
            background: #E3F2FD;
            border: 1px solid #BBDEFB;
            border-radius: 8px;
        }
        
        .auth-type-selector h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #1976D2;
        }
        
        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .radio-option {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .radio-option input[type="radio"] {
            margin: 0;
        }
        
        .radio-option label {
            margin: 0;
            font-weight: normal;
            cursor: pointer;
        }
        
        .qr-hint {
            margin-top: 10px;
            padding: 10px;
            background: #FFF9C4;
            border: 1px solid #FFF176;
            border-radius: 6px;
            font-size: 13px;
            color: #F57F17;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ” WebAuthn Passkey Demo</h1>
        
        <div class="fingerprint-icon">ğŸ‘†</div>
        
        <div class="form-group">
            <label for="email">Passkey åç§°:</label>
            <input type="email" id="email" placeholder="è¯·è¾“å…¥æ‚¨çš„Passkeyåç§°" value="user@example.com">
        </div>
        
        <div class="auth-type-selector">
            <h3>é€‰æ‹©è®¤è¯å™¨ç±»å‹</h3>
            <div class="radio-group">
                <div class="radio-option">
                    <input type="radio" id="platform" name="authType" value="platform" checked>
                    <label for="platform">ğŸ“± æœ¬è®¾å¤‡ç”Ÿç‰©è¯†åˆ«</label>
                </div>
                <div class="radio-option">
                    <input type="radio" id="cross-platform" name="authType" value="cross-platform">
                    <label for="cross-platform">ğŸ“² è·¨è®¾å¤‡ (æ‰«ç åˆ°æ‰‹æœº)</label>
                </div>
                <div class="radio-option">
                    <input type="radio" id="any" name="authType" value="any">
                    <label for="any">ğŸ”“ ä»»æ„å¯ç”¨è®¤è¯å™¨</label>
                </div>
            </div>
            <div id="qr-hint" class="qr-hint">
                <strong>ğŸ’¡ è·¨è®¾å¤‡æç¤º:</strong> é€‰æ‹©æ­¤é€‰é¡¹åï¼Œæ‚¨çš„è®¾å¤‡å¯èƒ½ä¼šæ˜¾ç¤ºäºŒç»´ç ï¼Œè¯·ä½¿ç”¨æ‰‹æœºæ‰«æäºŒç»´ç æ¥å®Œæˆè®¤è¯ã€‚è®¤è¯æˆåŠŸåï¼Œå‡­è¯å°†å­˜å‚¨åœ¨æ‚¨çš„æ‰‹æœºä¸Šã€‚
            </div>
        </div>
        
        <div class="button-group">
            <button id="register">ğŸ”‘ æ³¨å†Œ Passkey</button>
            <button id="login">ğŸš€ ä½¿ç”¨ Passkey ç™»å½•</button>
        </div>
        
        <div id="status" class="status"></div>
        
        <div class="support-info">
            <strong>æ”¯æŒæƒ…å†µ:</strong>
            <div id="support-status">æ­£åœ¨æ£€æŸ¥ WebAuthn æ”¯æŒ...</div>
        </div>
    </div>

    <script>
        // Utility functions for base64url encoding/decoding
        function base64urlToBuffer(base64url) {
            const base64 = base64url.replace(/-/g, '+').replace(/_/g, '/');
            const padded = base64.padEnd(base64.length + (4 - base64.length % 4) % 4, '=');
            const binary = atob(padded);
            return Uint8Array.from(binary, c => c.charCodeAt(0));
        }
        
        function bufferToBase64url(buffer) {
            const binary = String.fromCharCode(...new Uint8Array(buffer));
            const base64 = btoa(binary);
            return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
        }
        
        // Generate random challenge
        function generateChallenge() {
            const array = new Uint8Array(32);
            crypto.getRandomValues(array);
            return bufferToBase64url(array);
        }
        
        // Generate user ID
        function generateUserId(email) {
            const encoder = new TextEncoder();
            const data = encoder.encode(email + Date.now());
            return crypto.subtle.digest('SHA-256', data).then(hash => bufferToBase64url(hash));
        }
        
        // Show status message
        function showStatus(message, type = 'info') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
            status.style.display = 'block';
            
            if (type === 'success' || type === 'error') {
                setTimeout(() => {
                    status.style.display = 'none';
                }, 5000);
            }
        }
        
        // Check WebAuthn support
        function checkSupport() {
            const supportStatus = document.getElementById('support-status');
            
            if (!window.PublicKeyCredential) {
                supportStatus.innerHTML = 'âŒ æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ WebAuthn';
                document.getElementById('register').disabled = true;
                document.getElementById('login').disabled = true;
                return false;
            }
            
            let supportText = 'âœ… WebAuthn åŸºç¡€æ”¯æŒ: å¯ç”¨<br>';
            
            // Check platform authenticator
            PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable()
                .then(available => {
                    if (available) {
                        supportText += 'âœ… å¹³å°è®¤è¯å™¨ (ç”Ÿç‰©è¯†åˆ«): å¯ç”¨<br>';
                    } else {
                        supportText += 'âŒ å¹³å°è®¤è¯å™¨ (ç”Ÿç‰©è¯†åˆ«): ä¸å¯ç”¨<br>';
                    }
                    supportText += 'âœ… è·¨è®¾å¤‡è®¤è¯å™¨ (æ‰«ç ): å¯ç”¨';
                    supportStatus.innerHTML = supportText;
                })
                .catch(() => {
                    supportText += 'â“ å¹³å°è®¤è¯å™¨: æ£€æµ‹å¤±è´¥<br>';
                    supportText += 'âœ… è·¨è®¾å¤‡è®¤è¯å™¨ (æ‰«ç ): å¯ç”¨';
                    supportStatus.innerHTML = supportText;
                });
            
            return true;
        }
        
        // Get selected auth type
        function getSelectedAuthType() {
            const selected = document.querySelector('input[name="authType"]:checked');
            return selected ? selected.value : 'platform';
        }
        
        // Register passkey
        async function registerPasskey() {
            try {
                showStatus('æ­£åœ¨å‡†å¤‡æ³¨å†Œ...', 'info');
                
                const email = document.getElementById('email').value;
                if (!email) {
                    showStatus('è¯·è¾“å…¥é‚®ç®±åœ°å€', 'error');
                    return;
                }
                
                const userId = await generateUserId(email);
                const challenge = generateChallenge();
                const authType = getSelectedAuthType();
                
                // Get valid domain for WebAuthn
                const hostname = window.location.hostname;
                const rpId = hostname === '' || hostname === 'localhost' || window.location.protocol === 'file:' 
                    ? 'localhost' 
                    : hostname;
                
                // Configure authenticator selection based on user choice
                let authenticatorSelection = {
                    userVerification: "required",
                    requireResidentKey: true,
                };
                
                if (authType === 'platform') {
                    authenticatorSelection.authenticatorAttachment = "platform";
                } else if (authType === 'cross-platform') {
                    authenticatorSelection.authenticatorAttachment = "cross-platform";
                    // For cross-platform, we might not require resident key
                    authenticatorSelection.requireResidentKey = false;
                }
                // If authType === 'any', we don't specify authenticatorAttachment
                
                const publicKeyCredentialCreationOptions = {
                    challenge: base64urlToBuffer(challenge),
                    rp: {
                        name: "Tomo WebAuthn Demo",
                        id: "tomo.inc",
                    },
                    rpId: "tomo.inc",
                    user: {
                        id: base64urlToBuffer(userId),
                        name: email,
                        displayName: email.split('@')[0],
                    },
                    pubKeyCredParams: [
                        { alg: -7, type: "public-key" }, // ES256
                        { alg: -257, type: "public-key" }, // RS256
                    ],
                    authenticatorSelection: authenticatorSelection,
                    timeout: 60000,
                    attestation: "none"
                };
                
                // Show appropriate message based on auth type
                if (authType === 'platform') {
                    showStatus('è¯·ä½¿ç”¨ç”Ÿç‰©è¯†åˆ«å®Œæˆæ³¨å†Œ...', 'info');
                } else if (authType === 'cross-platform') {
                    showStatus('è¯·ä½¿ç”¨å¤–éƒ¨è®¤è¯å™¨å®Œæˆæ³¨å†Œã€‚å¦‚æœå‡ºç°äºŒç»´ç ï¼Œè¯·ç”¨æ‰‹æœºæ‰«æ...', 'info');
                } else {
                    showStatus('è¯·ä½¿ç”¨ä»»æ„å¯ç”¨çš„è®¤è¯å™¨å®Œæˆæ³¨å†Œ...', 'info');
                }
                
                const credential = await navigator.credentials.create({
                    publicKey: publicKeyCredentialCreationOptions
                });
                
                // Store credential info locally for demo purposes
                const credentialInfo = {
                    id: credential.id,
                    rawId: bufferToBase64url(credential.rawId),
                    type: credential.type,
                    email: email,
                    authType: authType,
                    createdAt: new Date().toISOString(),
                };
                
                localStorage.setItem('webauthn_credential', JSON.stringify(credentialInfo));
                
                // Show success message based on auth type
                let successMessage = 'ğŸ‰ Passkey æ³¨å†ŒæˆåŠŸï¼';
                if (authType === 'platform') {
                    successMessage += 'æ‚¨ç°åœ¨å¯ä»¥ä½¿ç”¨ç”Ÿç‰©è¯†åˆ«ç™»å½•äº†ã€‚';
                } else if (authType === 'cross-platform') {
                    successMessage += 'å‡­è¯å·²å­˜å‚¨åœ¨æ‚¨çš„å¤–éƒ¨è®¾å¤‡ä¸Šï¼Œæ‚¨ç°åœ¨å¯ä»¥ä½¿ç”¨è¯¥è®¾å¤‡ç™»å½•äº†ã€‚';
                } else {
                    successMessage += 'æ‚¨ç°åœ¨å¯ä»¥ä½¿ç”¨æ³¨å†Œçš„è®¤è¯å™¨ç™»å½•äº†ã€‚';
                }
                showStatus(successMessage, 'success');
                
            } catch (error) {
                console.error('Registration failed:', error);
                let errorMessage = 'æ³¨å†Œå¤±è´¥: ';
                
                if (error.name === 'NotAllowedError') {
                    errorMessage += 'ç”¨æˆ·å–æ¶ˆäº†æ“ä½œæˆ–è®¤è¯å¤±è´¥';
                } else if (error.name === 'InvalidStateError') {
                    errorMessage += 'è¯¥è®¾å¤‡ä¸Šå·²å­˜åœ¨ç›¸åŒçš„å‡­æ®';
                } else if (error.name === 'NotSupportedError') {
                    errorMessage += 'ä¸æ”¯æŒçš„æ“ä½œæˆ–ç®—æ³•';
                } else {
                    errorMessage += error.message || 'æœªçŸ¥é”™è¯¯';
                }
                
                showStatus(errorMessage, 'error');
            }
        }
        
        // Login with passkey
        async function loginWithPasskey() {
            try {
                showStatus('æ­£åœ¨å‡†å¤‡ç™»å½•...', 'info');
                
                const challenge = generateChallenge();
                const authType = getSelectedAuthType();
                
                const publicKeyCredentialRequestOptions = {
                    challenge: base64urlToBuffer(challenge),
                    allowCredentials: [], // Allow any registered credential  
                    userVerification: "required",
                    timeout: 60000,
                     rp: {
                            name: "Tomo WebAuthn Demo",
                            id: "tomo.inc",
                        },
                        rpId: "tomo.inc"
                };
                
                // Show appropriate message based on auth type
                if (authType === 'platform') {
                    showStatus('è¯·ä½¿ç”¨ç”Ÿç‰©è¯†åˆ«å®Œæˆç™»å½•...', 'info');
                } else if (authType === 'cross-platform') {
                    showStatus('è¯·ä½¿ç”¨å¤–éƒ¨è®¤è¯å™¨å®Œæˆç™»å½•ã€‚å¦‚æœå‡ºç°äºŒç»´ç ï¼Œè¯·ç”¨æ‰‹æœºæ‰«æ...', 'info');
                } else {
                    showStatus('è¯·ä½¿ç”¨ä»»æ„å¯ç”¨çš„è®¤è¯å™¨å®Œæˆç™»å½•...', 'info');
                }
                
                const assertion = await navigator.credentials.get({
                    publicKey: publicKeyCredentialRequestOptions
                });
                
                // In a real app, you would send this to your server for verification
                const authData = {
                    id: assertion.id,
                    rawId: bufferToBase64url(assertion.rawId),
                    type: assertion.type,
                    response: {
                        authenticatorData: bufferToBase64url(assertion.response.authenticatorData),
                        clientDataJSON: bufferToBase64url(assertion.response.clientDataJSON),
                        signature: bufferToBase64url(assertion.response.signature),
                        userHandle: assertion.response.userHandle ? bufferToBase64url(assertion.response.userHandle) : null,
                    }
                };
                
                // Check if we have stored credential info
                const storedCred = localStorage.getItem('webauthn_credential');
                let userInfo = 'æœªçŸ¥ç”¨æˆ·';
                
                if (storedCred) {
                    const credInfo = JSON.parse(storedCred);
                    if (credInfo.id === assertion.id) {
                        userInfo = credInfo.email;
                    }
                }
                
                showStatus(`ğŸ‰ ç™»å½•æˆåŠŸï¼æ¬¢è¿å›æ¥ï¼Œ${userInfo}`, 'success');
                
            } catch (error) {
                console.error('Login failed:', error);
                let errorMessage = 'ç™»å½•å¤±è´¥: ';
                
                if (error.name === 'NotAllowedError') {
                    errorMessage += 'ç”¨æˆ·å–æ¶ˆäº†æ“ä½œæˆ–è®¤è¯å¤±è´¥';
                } else if (error.name === 'InvalidStateError') {
                    errorMessage += 'æ²¡æœ‰æ‰¾åˆ°å¯ç”¨çš„å‡­æ®ï¼Œè¯·å…ˆæ³¨å†Œ';
                } else if (error.name === 'NotSupportedError') {
                    errorMessage += 'ä¸æ”¯æŒçš„æ“ä½œ';
                } else {
                    errorMessage += error.message || 'æœªçŸ¥é”™è¯¯';
                }
                
                showStatus(errorMessage, 'error');
            }
        }
        
        // Show/hide QR hint based on selected auth type
        function toggleQRHint() {
            const authType = getSelectedAuthType();
            const qrHint = document.getElementById('qr-hint');
            if (authType === 'cross-platform') {
                qrHint.style.display = 'block';
            } else {
                qrHint.style.display = 'none';
            }
        }
        
        // Event listeners
        document.getElementById('register').addEventListener('click', registerPasskey);
        document.getElementById('login').addEventListener('click', loginWithPasskey);
        
        // Add event listeners for radio buttons
        document.querySelectorAll('input[name="authType"]').forEach(radio => {
            radio.addEventListener('change', toggleQRHint);
        });
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            checkSupport();
            toggleQRHint(); // Initialize QR hint visibility
            
            // Check if there's a stored credential
            const storedCred = localStorage.getItem('webauthn_credential');
            if (storedCred) {
                const credInfo = JSON.parse(storedCred);
                document.getElementById('email').value = credInfo.email;
                let statusMsg = `æ‰¾åˆ°å·²æ³¨å†Œçš„ Passkey (${credInfo.email})`;
                if (credInfo.authType) {
                    const authTypeNames = {
                        'platform': 'æœ¬è®¾å¤‡ç”Ÿç‰©è¯†åˆ«',
                        'cross-platform': 'è·¨è®¾å¤‡',
                        'any': 'ä»»æ„è®¤è¯å™¨'
                    };
                    statusMsg += `ï¼Œç±»å‹: ${authTypeNames[credInfo.authType] || credInfo.authType}`;
                }
                statusMsg += 'ï¼Œæ‚¨å¯ä»¥ç›´æ¥ç™»å½•';
                showStatus(statusMsg, 'info');
            }
        });
    </script>
</body>
</html>
